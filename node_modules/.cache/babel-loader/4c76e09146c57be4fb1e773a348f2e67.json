{"ast":null,"code":"// Copyright 2015 Joyent, Inc.\nmodule.exports = Signature;\n\nvar assert = require('assert-plus');\n\nvar Buffer = require('safer-buffer').Buffer;\n\nvar algs = require('./algs');\n\nvar crypto = require('crypto');\n\nvar errs = require('./errors');\n\nvar utils = require('./utils');\n\nvar asn1 = require('asn1');\n\nvar SSHBuffer = require('./ssh-buffer');\n\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\nvar SignatureParseError = errs.SignatureParseError;\n\nfunction Signature(opts) {\n  assert.object(opts, 'options');\n  assert.arrayOfObject(opts.parts, 'options.parts');\n  assert.string(opts.type, 'options.type');\n  var partLookup = {};\n\n  for (var i = 0; i < opts.parts.length; ++i) {\n    var part = opts.parts[i];\n    partLookup[part.name] = part;\n  }\n\n  this.type = opts.type;\n  this.hashAlgorithm = opts.hashAlgo;\n  this.curve = opts.curve;\n  this.parts = opts.parts;\n  this.part = partLookup;\n}\n\nSignature.prototype.toBuffer = function (format) {\n  if (format === undefined) format = 'asn1';\n  assert.string(format, 'format');\n  var buf;\n  var stype = 'ssh-' + this.type;\n\n  switch (this.type) {\n    case 'rsa':\n      switch (this.hashAlgorithm) {\n        case 'sha256':\n          stype = 'rsa-sha2-256';\n          break;\n\n        case 'sha512':\n          stype = 'rsa-sha2-512';\n          break;\n\n        case 'sha1':\n        case undefined:\n          break;\n\n        default:\n          throw new Error('SSH signature ' + 'format does not support hash ' + 'algorithm ' + this.hashAlgorithm);\n      }\n\n      if (format === 'ssh') {\n        buf = new SSHBuffer({});\n        buf.writeString(stype);\n        buf.writePart(this.part.sig);\n        return buf.toBuffer();\n      } else {\n        return this.part.sig.data;\n      }\n\n      break;\n\n    case 'ed25519':\n      if (format === 'ssh') {\n        buf = new SSHBuffer({});\n        buf.writeString(stype);\n        buf.writePart(this.part.sig);\n        return buf.toBuffer();\n      } else {\n        return this.part.sig.data;\n      }\n\n      break;\n\n    case 'dsa':\n    case 'ecdsa':\n      var r, s;\n\n      if (format === 'asn1') {\n        var der = new asn1.BerWriter();\n        der.startSequence();\n        r = utils.mpNormalize(this.part.r.data);\n        s = utils.mpNormalize(this.part.s.data);\n        der.writeBuffer(r, asn1.Ber.Integer);\n        der.writeBuffer(s, asn1.Ber.Integer);\n        der.endSequence();\n        return der.buffer;\n      } else if (format === 'ssh' && this.type === 'dsa') {\n        buf = new SSHBuffer({});\n        buf.writeString('ssh-dss');\n        r = this.part.r.data;\n        if (r.length > 20 && r[0] === 0x00) r = r.slice(1);\n        s = this.part.s.data;\n        if (s.length > 20 && s[0] === 0x00) s = s.slice(1);\n\n        if (this.hashAlgorithm && this.hashAlgorithm !== 'sha1' || r.length + s.length !== 40) {\n          throw new Error('OpenSSH only supports ' + 'DSA signatures with SHA1 hash');\n        }\n\n        buf.writeBuffer(Buffer.concat([r, s]));\n        return buf.toBuffer();\n      } else if (format === 'ssh' && this.type === 'ecdsa') {\n        var inner = new SSHBuffer({});\n        r = this.part.r.data;\n        inner.writeBuffer(r);\n        inner.writePart(this.part.s);\n        buf = new SSHBuffer({});\n        /* XXX: find a more proper way to do this? */\n\n        var curve;\n        if (r[0] === 0x00) r = r.slice(1);\n        var sz = r.length * 8;\n        if (sz === 256) curve = 'nistp256';else if (sz === 384) curve = 'nistp384';else if (sz === 528) curve = 'nistp521';\n        buf.writeString('ecdsa-sha2-' + curve);\n        buf.writeBuffer(inner.toBuffer());\n        return buf.toBuffer();\n      }\n\n      throw new Error('Invalid signature format');\n\n    default:\n      throw new Error('Invalid signature data');\n  }\n};\n\nSignature.prototype.toString = function (format) {\n  assert.optionalString(format, 'format');\n  return this.toBuffer(format).toString('base64');\n};\n\nSignature.parse = function (data, type, format) {\n  if (typeof data === 'string') data = Buffer.from(data, 'base64');\n  assert.buffer(data, 'data');\n  assert.string(format, 'format');\n  assert.string(type, 'type');\n  var opts = {};\n  opts.type = type.toLowerCase();\n  opts.parts = [];\n\n  try {\n    assert.ok(data.length > 0, 'signature must not be empty');\n\n    switch (opts.type) {\n      case 'rsa':\n        return parseOneNum(data, type, format, opts);\n\n      case 'ed25519':\n        return parseOneNum(data, type, format, opts);\n\n      case 'dsa':\n      case 'ecdsa':\n        if (format === 'asn1') return parseDSAasn1(data, type, format, opts);else if (opts.type === 'dsa') return parseDSA(data, type, format, opts);else return parseECDSA(data, type, format, opts);\n\n      default:\n        throw new InvalidAlgorithmError(type);\n    }\n  } catch (e) {\n    if (e instanceof InvalidAlgorithmError) throw e;\n    throw new SignatureParseError(type, format, e);\n  }\n};\n\nfunction parseOneNum(data, type, format, opts) {\n  if (format === 'ssh') {\n    try {\n      var buf = new SSHBuffer({\n        buffer: data\n      });\n      var head = buf.readString();\n    } catch (e) {\n      /* fall through */\n    }\n\n    if (buf !== undefined) {\n      var msg = 'SSH signature does not match expected ' + 'type (expected ' + type + ', got ' + head + ')';\n\n      switch (head) {\n        case 'ssh-rsa':\n          assert.strictEqual(type, 'rsa', msg);\n          opts.hashAlgo = 'sha1';\n          break;\n\n        case 'rsa-sha2-256':\n          assert.strictEqual(type, 'rsa', msg);\n          opts.hashAlgo = 'sha256';\n          break;\n\n        case 'rsa-sha2-512':\n          assert.strictEqual(type, 'rsa', msg);\n          opts.hashAlgo = 'sha512';\n          break;\n\n        case 'ssh-ed25519':\n          assert.strictEqual(type, 'ed25519', msg);\n          opts.hashAlgo = 'sha512';\n          break;\n\n        default:\n          throw new Error('Unknown SSH signature ' + 'type: ' + head);\n      }\n\n      var sig = buf.readPart();\n      assert.ok(buf.atEnd(), 'extra trailing bytes');\n      sig.name = 'sig';\n      opts.parts.push(sig);\n      return new Signature(opts);\n    }\n  }\n\n  opts.parts.push({\n    name: 'sig',\n    data: data\n  });\n  return new Signature(opts);\n}\n\nfunction parseDSAasn1(data, type, format, opts) {\n  var der = new asn1.BerReader(data);\n  der.readSequence();\n  var r = der.readString(asn1.Ber.Integer, true);\n  var s = der.readString(asn1.Ber.Integer, true);\n  opts.parts.push({\n    name: 'r',\n    data: utils.mpNormalize(r)\n  });\n  opts.parts.push({\n    name: 's',\n    data: utils.mpNormalize(s)\n  });\n  return new Signature(opts);\n}\n\nfunction parseDSA(data, type, format, opts) {\n  if (data.length != 40) {\n    var buf = new SSHBuffer({\n      buffer: data\n    });\n    var d = buf.readBuffer();\n    if (d.toString('ascii') === 'ssh-dss') d = buf.readBuffer();\n    assert.ok(buf.atEnd(), 'extra trailing bytes');\n    assert.strictEqual(d.length, 40, 'invalid inner length');\n    data = d;\n  }\n\n  opts.parts.push({\n    name: 'r',\n    data: data.slice(0, 20)\n  });\n  opts.parts.push({\n    name: 's',\n    data: data.slice(20, 40)\n  });\n  return new Signature(opts);\n}\n\nfunction parseECDSA(data, type, format, opts) {\n  var buf = new SSHBuffer({\n    buffer: data\n  });\n  var r, s;\n  var inner = buf.readBuffer();\n  var stype = inner.toString('ascii');\n\n  if (stype.slice(0, 6) === 'ecdsa-') {\n    var parts = stype.split('-');\n    assert.strictEqual(parts[0], 'ecdsa');\n    assert.strictEqual(parts[1], 'sha2');\n    opts.curve = parts[2];\n\n    switch (opts.curve) {\n      case 'nistp256':\n        opts.hashAlgo = 'sha256';\n        break;\n\n      case 'nistp384':\n        opts.hashAlgo = 'sha384';\n        break;\n\n      case 'nistp521':\n        opts.hashAlgo = 'sha512';\n        break;\n\n      default:\n        throw new Error('Unsupported ECDSA curve: ' + opts.curve);\n    }\n\n    inner = buf.readBuffer();\n    assert.ok(buf.atEnd(), 'extra trailing bytes on outer');\n    buf = new SSHBuffer({\n      buffer: inner\n    });\n    r = buf.readPart();\n  } else {\n    r = {\n      data: inner\n    };\n  }\n\n  s = buf.readPart();\n  assert.ok(buf.atEnd(), 'extra trailing bytes');\n  r.name = 'r';\n  s.name = 's';\n  opts.parts.push(r);\n  opts.parts.push(s);\n  return new Signature(opts);\n}\n\nSignature.isSignature = function (obj, ver) {\n  return utils.isCompatible(obj, Signature, ver);\n};\n/*\n * API versions for Signature:\n * [1,0] -- initial ver\n * [2,0] -- support for rsa in full ssh format, compat with sshpk-agent\n *          hashAlgorithm property\n * [2,1] -- first tagged version\n */\n\n\nSignature.prototype._sshpkApiVersion = [2, 1];\n\nSignature._oldVersionDetect = function (obj) {\n  assert.func(obj.toBuffer);\n  if (obj.hasOwnProperty('hashAlgorithm')) return [2, 0];\n  return [1, 0];\n};","map":null,"metadata":{},"sourceType":"script"}