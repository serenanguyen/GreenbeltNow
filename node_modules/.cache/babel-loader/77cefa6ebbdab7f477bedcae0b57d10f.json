{"ast":null,"code":"var crypto = require('crypto');\n\nfunction sha(key, body, algorithm) {\n  return crypto.createHmac(algorithm, key).update(body).digest('base64');\n}\n\nfunction rsa(key, body) {\n  return crypto.createSign('RSA-SHA1').update(body).sign(key, 'base64');\n}\n\nfunction rfc3986(str) {\n  return encodeURIComponent(str).replace(/!/g, '%21').replace(/\\*/g, '%2A').replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/'/g, '%27');\n} // Maps object to bi-dimensional array\n// Converts { foo: 'A', bar: [ 'b', 'B' ]} to\n// [ ['foo', 'A'], ['bar', 'b'], ['bar', 'B'] ]\n\n\nfunction map(obj) {\n  var key,\n      val,\n      arr = [];\n\n  for (key in obj) {\n    val = obj[key];\n    if (Array.isArray(val)) for (var i = 0; i < val.length; i++) arr.push([key, val[i]]);else if (typeof val === 'object') for (var prop in val) arr.push([key + '[' + prop + ']', val[prop]]);else arr.push([key, val]);\n  }\n\n  return arr;\n} // Compare function for sort\n\n\nfunction compare(a, b) {\n  return a > b ? 1 : a < b ? -1 : 0;\n}\n\nfunction generateBase(httpMethod, base_uri, params) {\n  // adapted from https://dev.twitter.com/docs/auth/oauth and \n  // https://dev.twitter.com/docs/auth/creating-signature\n  // Parameter normalization\n  // http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2\n  var normalized = map(params) // 1.  First, the name and value of each parameter are encoded\n  .map(function (p) {\n    return [rfc3986(p[0]), rfc3986(p[1] || '')];\n  }) // 2.  The parameters are sorted by name, using ascending byte value\n  //     ordering.  If two or more parameters share the same name, they\n  //     are sorted by their value.\n  .sort(function (a, b) {\n    return compare(a[0], b[0]) || compare(a[1], b[1]);\n  }) // 3.  The name of each parameter is concatenated to its corresponding\n  //     value using an \"=\" character (ASCII code 61) as a separator, even\n  //     if the value is empty.\n  .map(function (p) {\n    return p.join('=');\n  }) // 4.  The sorted name/value pairs are concatenated together into a\n  //     single string by using an \"&\" character (ASCII code 38) as\n  //     separator.\n  .join('&');\n  var base = [rfc3986(httpMethod ? httpMethod.toUpperCase() : 'GET'), rfc3986(base_uri), rfc3986(normalized)].join('&');\n  return base;\n}\n\nfunction hmacsign(httpMethod, base_uri, params, consumer_secret, token_secret) {\n  var base = generateBase(httpMethod, base_uri, params);\n  var key = [consumer_secret || '', token_secret || ''].map(rfc3986).join('&');\n  return sha(key, base, 'sha1');\n}\n\nfunction hmacsign256(httpMethod, base_uri, params, consumer_secret, token_secret) {\n  var base = generateBase(httpMethod, base_uri, params);\n  var key = [consumer_secret || '', token_secret || ''].map(rfc3986).join('&');\n  return sha(key, base, 'sha256');\n}\n\nfunction rsasign(httpMethod, base_uri, params, private_key, token_secret) {\n  var base = generateBase(httpMethod, base_uri, params);\n  var key = private_key || '';\n  return rsa(key, base);\n}\n\nfunction plaintext(consumer_secret, token_secret) {\n  var key = [consumer_secret || '', token_secret || ''].map(rfc3986).join('&');\n  return key;\n}\n\nfunction sign(signMethod, httpMethod, base_uri, params, consumer_secret, token_secret) {\n  var method;\n  var skipArgs = 1;\n\n  switch (signMethod) {\n    case 'RSA-SHA1':\n      method = rsasign;\n      break;\n\n    case 'HMAC-SHA1':\n      method = hmacsign;\n      break;\n\n    case 'HMAC-SHA256':\n      method = hmacsign256;\n      break;\n\n    case 'PLAINTEXT':\n      method = plaintext;\n      skipArgs = 4;\n      break;\n\n    default:\n      throw new Error('Signature method not supported: ' + signMethod);\n  }\n\n  return method.apply(null, [].slice.call(arguments, skipArgs));\n}\n\nexports.hmacsign = hmacsign;\nexports.hmacsign256 = hmacsign256;\nexports.rsasign = rsasign;\nexports.plaintext = plaintext;\nexports.sign = sign;\nexports.rfc3986 = rfc3986;\nexports.generateBase = generateBase;","map":null,"metadata":{},"sourceType":"script"}