{"ast":null,"code":"// Copyright 2018 Joyent, Inc.\nmodule.exports = Key;\n\nvar assert = require('assert-plus');\n\nvar algs = require('./algs');\n\nvar crypto = require('crypto');\n\nvar Fingerprint = require('./fingerprint');\n\nvar Signature = require('./signature');\n\nvar DiffieHellman = require('./dhe').DiffieHellman;\n\nvar errs = require('./errors');\n\nvar utils = require('./utils');\n\nvar PrivateKey = require('./private-key');\n\nvar edCompat;\n\ntry {\n  edCompat = require('./ed-compat');\n} catch (e) {\n  /* Just continue through, and bail out if we try to use it. */\n}\n\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\nvar KeyParseError = errs.KeyParseError;\nvar formats = {};\nformats['auto'] = require('./formats/auto');\nformats['pem'] = require('./formats/pem');\nformats['pkcs1'] = require('./formats/pkcs1');\nformats['pkcs8'] = require('./formats/pkcs8');\nformats['rfc4253'] = require('./formats/rfc4253');\nformats['ssh'] = require('./formats/ssh');\nformats['ssh-private'] = require('./formats/ssh-private');\nformats['openssh'] = formats['ssh-private'];\nformats['dnssec'] = require('./formats/dnssec');\nformats['putty'] = require('./formats/putty');\nformats['ppk'] = formats['putty'];\n\nfunction Key(opts) {\n  assert.object(opts, 'options');\n  assert.arrayOfObject(opts.parts, 'options.parts');\n  assert.string(opts.type, 'options.type');\n  assert.optionalString(opts.comment, 'options.comment');\n  var algInfo = algs.info[opts.type];\n  if (typeof algInfo !== 'object') throw new InvalidAlgorithmError(opts.type);\n  var partLookup = {};\n\n  for (var i = 0; i < opts.parts.length; ++i) {\n    var part = opts.parts[i];\n    partLookup[part.name] = part;\n  }\n\n  this.type = opts.type;\n  this.parts = opts.parts;\n  this.part = partLookup;\n  this.comment = undefined;\n  this.source = opts.source;\n  /* for speeding up hashing/fingerprint operations */\n\n  this._rfc4253Cache = opts._rfc4253Cache;\n  this._hashCache = {};\n  var sz;\n  this.curve = undefined;\n\n  if (this.type === 'ecdsa') {\n    var curve = this.part.curve.data.toString();\n    this.curve = curve;\n    sz = algs.curves[curve].size;\n  } else if (this.type === 'ed25519' || this.type === 'curve25519') {\n    sz = 256;\n    this.curve = 'curve25519';\n  } else {\n    var szPart = this.part[algInfo.sizePart];\n    sz = szPart.data.length;\n    sz = sz * 8 - utils.countZeros(szPart.data);\n  }\n\n  this.size = sz;\n}\n\nKey.formats = formats;\n\nKey.prototype.toBuffer = function (format, options) {\n  if (format === undefined) format = 'ssh';\n  assert.string(format, 'format');\n  assert.object(formats[format], 'formats[format]');\n  assert.optionalObject(options, 'options');\n\n  if (format === 'rfc4253') {\n    if (this._rfc4253Cache === undefined) this._rfc4253Cache = formats['rfc4253'].write(this);\n    return this._rfc4253Cache;\n  }\n\n  return formats[format].write(this, options);\n};\n\nKey.prototype.toString = function (format, options) {\n  return this.toBuffer(format, options).toString();\n};\n\nKey.prototype.hash = function (algo, type) {\n  assert.string(algo, 'algorithm');\n  assert.optionalString(type, 'type');\n  if (type === undefined) type = 'ssh';\n  algo = algo.toLowerCase();\n  if (algs.hashAlgs[algo] === undefined) throw new InvalidAlgorithmError(algo);\n  var cacheKey = algo + '||' + type;\n  if (this._hashCache[cacheKey]) return this._hashCache[cacheKey];\n  var buf;\n\n  if (type === 'ssh') {\n    buf = this.toBuffer('rfc4253');\n  } else if (type === 'spki') {\n    buf = formats.pkcs8.pkcs8ToBuffer(this);\n  } else {\n    throw new Error('Hash type ' + type + ' not supported');\n  }\n\n  var hash = crypto.createHash(algo).update(buf).digest();\n  this._hashCache[cacheKey] = hash;\n  return hash;\n};\n\nKey.prototype.fingerprint = function (algo, type) {\n  if (algo === undefined) algo = 'sha256';\n  if (type === undefined) type = 'ssh';\n  assert.string(algo, 'algorithm');\n  assert.string(type, 'type');\n  var opts = {\n    type: 'key',\n    hash: this.hash(algo, type),\n    algorithm: algo,\n    hashType: type\n  };\n  return new Fingerprint(opts);\n};\n\nKey.prototype.defaultHashAlgorithm = function () {\n  var hashAlgo = 'sha1';\n  if (this.type === 'rsa') hashAlgo = 'sha256';\n  if (this.type === 'dsa' && this.size > 1024) hashAlgo = 'sha256';\n  if (this.type === 'ed25519') hashAlgo = 'sha512';\n\n  if (this.type === 'ecdsa') {\n    if (this.size <= 256) hashAlgo = 'sha256';else if (this.size <= 384) hashAlgo = 'sha384';else hashAlgo = 'sha512';\n  }\n\n  return hashAlgo;\n};\n\nKey.prototype.createVerify = function (hashAlgo) {\n  if (hashAlgo === undefined) hashAlgo = this.defaultHashAlgorithm();\n  assert.string(hashAlgo, 'hash algorithm');\n  /* ED25519 is not supported by OpenSSL, use a javascript impl. */\n\n  if (this.type === 'ed25519' && edCompat !== undefined) return new edCompat.Verifier(this, hashAlgo);\n  if (this.type === 'curve25519') throw new Error('Curve25519 keys are not suitable for ' + 'signing or verification');\n  var v, nm, err;\n\n  try {\n    nm = hashAlgo.toUpperCase();\n    v = crypto.createVerify(nm);\n  } catch (e) {\n    err = e;\n  }\n\n  if (v === undefined || err instanceof Error && err.message.match(/Unknown message digest/)) {\n    nm = 'RSA-';\n    nm += hashAlgo.toUpperCase();\n    v = crypto.createVerify(nm);\n  }\n\n  assert.ok(v, 'failed to create verifier');\n  var oldVerify = v.verify.bind(v);\n  var key = this.toBuffer('pkcs8');\n  var curve = this.curve;\n  var self = this;\n\n  v.verify = function (signature, fmt) {\n    if (Signature.isSignature(signature, [2, 0])) {\n      if (signature.type !== self.type) return false;\n      if (signature.hashAlgorithm && signature.hashAlgorithm !== hashAlgo) return false;\n      if (signature.curve && self.type === 'ecdsa' && signature.curve !== curve) return false;\n      return oldVerify(key, signature.toBuffer('asn1'));\n    } else if (typeof signature === 'string' || Buffer.isBuffer(signature)) {\n      return oldVerify(key, signature, fmt);\n      /*\n       * Avoid doing this on valid arguments, walking the prototype\n       * chain can be quite slow.\n       */\n    } else if (Signature.isSignature(signature, [1, 0])) {\n      throw new Error('signature was created by too old ' + 'a version of sshpk and cannot be verified');\n    } else {\n      throw new TypeError('signature must be a string, ' + 'Buffer, or Signature object');\n    }\n  };\n\n  return v;\n};\n\nKey.prototype.createDiffieHellman = function () {\n  if (this.type === 'rsa') throw new Error('RSA keys do not support Diffie-Hellman');\n  return new DiffieHellman(this);\n};\n\nKey.prototype.createDH = Key.prototype.createDiffieHellman;\n\nKey.parse = function (data, format, options) {\n  if (typeof data !== 'string') assert.buffer(data, 'data');\n  if (format === undefined) format = 'auto';\n  assert.string(format, 'format');\n  if (typeof options === 'string') options = {\n    filename: options\n  };\n  assert.optionalObject(options, 'options');\n  if (options === undefined) options = {};\n  assert.optionalString(options.filename, 'options.filename');\n  if (options.filename === undefined) options.filename = '(unnamed)';\n  assert.object(formats[format], 'formats[format]');\n\n  try {\n    var k = formats[format].read(data, options);\n    if (k instanceof PrivateKey) k = k.toPublic();\n    if (!k.comment) k.comment = options.filename;\n    return k;\n  } catch (e) {\n    if (e.name === 'KeyEncryptedError') throw e;\n    throw new KeyParseError(options.filename, format, e);\n  }\n};\n\nKey.isKey = function (obj, ver) {\n  return utils.isCompatible(obj, Key, ver);\n};\n/*\n * API versions for Key:\n * [1,0] -- initial ver, may take Signature for createVerify or may not\n * [1,1] -- added pkcs1, pkcs8 formats\n * [1,2] -- added auto, ssh-private, openssh formats\n * [1,3] -- added defaultHashAlgorithm\n * [1,4] -- added ed support, createDH\n * [1,5] -- first explicitly tagged version\n * [1,6] -- changed ed25519 part names\n * [1,7] -- spki hash types\n */\n\n\nKey.prototype._sshpkApiVersion = [1, 7];\n\nKey._oldVersionDetect = function (obj) {\n  assert.func(obj.toBuffer);\n  assert.func(obj.fingerprint);\n  if (obj.createDH) return [1, 4];\n  if (obj.defaultHashAlgorithm) return [1, 3];\n  if (obj.formats['auto']) return [1, 2];\n  if (obj.formats['pkcs1']) return [1, 1];\n  return [1, 0];\n};","map":null,"metadata":{},"sourceType":"script"}