{"ast":null,"code":"// Copyright 2015 Joyent, Inc.\nmodule.exports = {\n  read: read,\n  readPkcs1: readPkcs1,\n  write: write,\n  writePkcs1: writePkcs1\n};\n\nvar assert = require('assert-plus');\n\nvar asn1 = require('asn1');\n\nvar Buffer = require('safer-buffer').Buffer;\n\nvar algs = require('../algs');\n\nvar utils = require('../utils');\n\nvar Key = require('../key');\n\nvar PrivateKey = require('../private-key');\n\nvar pem = require('./pem');\n\nvar pkcs8 = require('./pkcs8');\n\nvar readECDSACurve = pkcs8.readECDSACurve;\n\nfunction read(buf, options) {\n  return pem.read(buf, options, 'pkcs1');\n}\n\nfunction write(key, options) {\n  return pem.write(key, options, 'pkcs1');\n}\n/* Helper to read in a single mpint */\n\n\nfunction readMPInt(der, nm) {\n  assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + ' is not an Integer');\n  return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));\n}\n\nfunction readPkcs1(alg, type, der) {\n  switch (alg) {\n    case 'RSA':\n      if (type === 'public') return readPkcs1RSAPublic(der);else if (type === 'private') return readPkcs1RSAPrivate(der);\n      throw new Error('Unknown key type: ' + type);\n\n    case 'DSA':\n      if (type === 'public') return readPkcs1DSAPublic(der);else if (type === 'private') return readPkcs1DSAPrivate(der);\n      throw new Error('Unknown key type: ' + type);\n\n    case 'EC':\n    case 'ECDSA':\n      if (type === 'private') return readPkcs1ECDSAPrivate(der);else if (type === 'public') return readPkcs1ECDSAPublic(der);\n      throw new Error('Unknown key type: ' + type);\n\n    case 'EDDSA':\n    case 'EdDSA':\n      if (type === 'private') return readPkcs1EdDSAPrivate(der);\n      throw new Error(type + ' keys not supported with EdDSA');\n\n    default:\n      throw new Error('Unknown key algo: ' + alg);\n  }\n}\n\nfunction readPkcs1RSAPublic(der) {\n  // modulus and exponent\n  var n = readMPInt(der, 'modulus');\n  var e = readMPInt(der, 'exponent'); // now, make the key\n\n  var key = {\n    type: 'rsa',\n    parts: [{\n      name: 'e',\n      data: e\n    }, {\n      name: 'n',\n      data: n\n    }]\n  };\n  return new Key(key);\n}\n\nfunction readPkcs1RSAPrivate(der) {\n  var version = readMPInt(der, 'version');\n  assert.strictEqual(version[0], 0); // modulus then public exponent\n\n  var n = readMPInt(der, 'modulus');\n  var e = readMPInt(der, 'public exponent');\n  var d = readMPInt(der, 'private exponent');\n  var p = readMPInt(der, 'prime1');\n  var q = readMPInt(der, 'prime2');\n  var dmodp = readMPInt(der, 'exponent1');\n  var dmodq = readMPInt(der, 'exponent2');\n  var iqmp = readMPInt(der, 'iqmp'); // now, make the key\n\n  var key = {\n    type: 'rsa',\n    parts: [{\n      name: 'n',\n      data: n\n    }, {\n      name: 'e',\n      data: e\n    }, {\n      name: 'd',\n      data: d\n    }, {\n      name: 'iqmp',\n      data: iqmp\n    }, {\n      name: 'p',\n      data: p\n    }, {\n      name: 'q',\n      data: q\n    }, {\n      name: 'dmodp',\n      data: dmodp\n    }, {\n      name: 'dmodq',\n      data: dmodq\n    }]\n  };\n  return new PrivateKey(key);\n}\n\nfunction readPkcs1DSAPrivate(der) {\n  var version = readMPInt(der, 'version');\n  assert.strictEqual(version.readUInt8(0), 0);\n  var p = readMPInt(der, 'p');\n  var q = readMPInt(der, 'q');\n  var g = readMPInt(der, 'g');\n  var y = readMPInt(der, 'y');\n  var x = readMPInt(der, 'x'); // now, make the key\n\n  var key = {\n    type: 'dsa',\n    parts: [{\n      name: 'p',\n      data: p\n    }, {\n      name: 'q',\n      data: q\n    }, {\n      name: 'g',\n      data: g\n    }, {\n      name: 'y',\n      data: y\n    }, {\n      name: 'x',\n      data: x\n    }]\n  };\n  return new PrivateKey(key);\n}\n\nfunction readPkcs1EdDSAPrivate(der) {\n  var version = readMPInt(der, 'version');\n  assert.strictEqual(version.readUInt8(0), 1); // private key\n\n  var k = der.readString(asn1.Ber.OctetString, true);\n  der.readSequence(0xa0);\n  var oid = der.readOID();\n  assert.strictEqual(oid, '1.3.101.112', 'the ed25519 curve identifier');\n  der.readSequence(0xa1);\n  var A = utils.readBitString(der);\n  var key = {\n    type: 'ed25519',\n    parts: [{\n      name: 'A',\n      data: utils.zeroPadToLength(A, 32)\n    }, {\n      name: 'k',\n      data: k\n    }]\n  };\n  return new PrivateKey(key);\n}\n\nfunction readPkcs1DSAPublic(der) {\n  var y = readMPInt(der, 'y');\n  var p = readMPInt(der, 'p');\n  var q = readMPInt(der, 'q');\n  var g = readMPInt(der, 'g');\n  var key = {\n    type: 'dsa',\n    parts: [{\n      name: 'y',\n      data: y\n    }, {\n      name: 'p',\n      data: p\n    }, {\n      name: 'q',\n      data: q\n    }, {\n      name: 'g',\n      data: g\n    }]\n  };\n  return new Key(key);\n}\n\nfunction readPkcs1ECDSAPublic(der) {\n  der.readSequence();\n  var oid = der.readOID();\n  assert.strictEqual(oid, '1.2.840.10045.2.1', 'must be ecPublicKey');\n  var curveOid = der.readOID();\n  var curve;\n  var curves = Object.keys(algs.curves);\n\n  for (var j = 0; j < curves.length; ++j) {\n    var c = curves[j];\n    var cd = algs.curves[c];\n\n    if (cd.pkcs8oid === curveOid) {\n      curve = c;\n      break;\n    }\n  }\n\n  assert.string(curve, 'a known ECDSA named curve');\n  var Q = der.readString(asn1.Ber.BitString, true);\n  Q = utils.ecNormalize(Q);\n  var key = {\n    type: 'ecdsa',\n    parts: [{\n      name: 'curve',\n      data: Buffer.from(curve)\n    }, {\n      name: 'Q',\n      data: Q\n    }]\n  };\n  return new Key(key);\n}\n\nfunction readPkcs1ECDSAPrivate(der) {\n  var version = readMPInt(der, 'version');\n  assert.strictEqual(version.readUInt8(0), 1); // private key\n\n  var d = der.readString(asn1.Ber.OctetString, true);\n  der.readSequence(0xa0);\n  var curve = readECDSACurve(der);\n  assert.string(curve, 'a known elliptic curve');\n  der.readSequence(0xa1);\n  var Q = der.readString(asn1.Ber.BitString, true);\n  Q = utils.ecNormalize(Q);\n  var key = {\n    type: 'ecdsa',\n    parts: [{\n      name: 'curve',\n      data: Buffer.from(curve)\n    }, {\n      name: 'Q',\n      data: Q\n    }, {\n      name: 'd',\n      data: d\n    }]\n  };\n  return new PrivateKey(key);\n}\n\nfunction writePkcs1(der, key) {\n  der.startSequence();\n\n  switch (key.type) {\n    case 'rsa':\n      if (PrivateKey.isPrivateKey(key)) writePkcs1RSAPrivate(der, key);else writePkcs1RSAPublic(der, key);\n      break;\n\n    case 'dsa':\n      if (PrivateKey.isPrivateKey(key)) writePkcs1DSAPrivate(der, key);else writePkcs1DSAPublic(der, key);\n      break;\n\n    case 'ecdsa':\n      if (PrivateKey.isPrivateKey(key)) writePkcs1ECDSAPrivate(der, key);else writePkcs1ECDSAPublic(der, key);\n      break;\n\n    case 'ed25519':\n      if (PrivateKey.isPrivateKey(key)) writePkcs1EdDSAPrivate(der, key);else writePkcs1EdDSAPublic(der, key);\n      break;\n\n    default:\n      throw new Error('Unknown key algo: ' + key.type);\n  }\n\n  der.endSequence();\n}\n\nfunction writePkcs1RSAPublic(der, key) {\n  der.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n  der.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n}\n\nfunction writePkcs1RSAPrivate(der, key) {\n  var ver = Buffer.from([0]);\n  der.writeBuffer(ver, asn1.Ber.Integer);\n  der.writeBuffer(key.part.n.data, asn1.Ber.Integer);\n  der.writeBuffer(key.part.e.data, asn1.Ber.Integer);\n  der.writeBuffer(key.part.d.data, asn1.Ber.Integer);\n  der.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n  der.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n  if (!key.part.dmodp || !key.part.dmodq) utils.addRSAMissing(key);\n  der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);\n  der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);\n  der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);\n}\n\nfunction writePkcs1DSAPrivate(der, key) {\n  var ver = Buffer.from([0]);\n  der.writeBuffer(ver, asn1.Ber.Integer);\n  der.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n  der.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n  der.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n  der.writeBuffer(key.part.y.data, asn1.Ber.Integer);\n  der.writeBuffer(key.part.x.data, asn1.Ber.Integer);\n}\n\nfunction writePkcs1DSAPublic(der, key) {\n  der.writeBuffer(key.part.y.data, asn1.Ber.Integer);\n  der.writeBuffer(key.part.p.data, asn1.Ber.Integer);\n  der.writeBuffer(key.part.q.data, asn1.Ber.Integer);\n  der.writeBuffer(key.part.g.data, asn1.Ber.Integer);\n}\n\nfunction writePkcs1ECDSAPublic(der, key) {\n  der.startSequence();\n  der.writeOID('1.2.840.10045.2.1');\n  /* ecPublicKey */\n\n  var curve = key.part.curve.data.toString();\n  var curveOid = algs.curves[curve].pkcs8oid;\n  assert.string(curveOid, 'a known ECDSA named curve');\n  der.writeOID(curveOid);\n  der.endSequence();\n  var Q = utils.ecNormalize(key.part.Q.data, true);\n  der.writeBuffer(Q, asn1.Ber.BitString);\n}\n\nfunction writePkcs1ECDSAPrivate(der, key) {\n  var ver = Buffer.from([1]);\n  der.writeBuffer(ver, asn1.Ber.Integer);\n  der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);\n  der.startSequence(0xa0);\n  var curve = key.part.curve.data.toString();\n  var curveOid = algs.curves[curve].pkcs8oid;\n  assert.string(curveOid, 'a known ECDSA named curve');\n  der.writeOID(curveOid);\n  der.endSequence();\n  der.startSequence(0xa1);\n  var Q = utils.ecNormalize(key.part.Q.data, true);\n  der.writeBuffer(Q, asn1.Ber.BitString);\n  der.endSequence();\n}\n\nfunction writePkcs1EdDSAPrivate(der, key) {\n  var ver = Buffer.from([1]);\n  der.writeBuffer(ver, asn1.Ber.Integer);\n  der.writeBuffer(key.part.k.data, asn1.Ber.OctetString);\n  der.startSequence(0xa0);\n  der.writeOID('1.3.101.112');\n  der.endSequence();\n  der.startSequence(0xa1);\n  utils.writeBitString(der, key.part.A.data);\n  der.endSequence();\n}\n\nfunction writePkcs1EdDSAPublic(der, key) {\n  throw new Error('Public keys are not supported for EdDSA PKCS#1');\n}","map":null,"metadata":{},"sourceType":"script"}