{"ast":null,"code":"// Copyright 2016 Joyent, Inc.\nmodule.exports = Certificate;\n\nvar assert = require('assert-plus');\n\nvar Buffer = require('safer-buffer').Buffer;\n\nvar algs = require('./algs');\n\nvar crypto = require('crypto');\n\nvar Fingerprint = require('./fingerprint');\n\nvar Signature = require('./signature');\n\nvar errs = require('./errors');\n\nvar util = require('util');\n\nvar utils = require('./utils');\n\nvar Key = require('./key');\n\nvar PrivateKey = require('./private-key');\n\nvar Identity = require('./identity');\n\nvar formats = {};\nformats['openssh'] = require('./formats/openssh-cert');\nformats['x509'] = require('./formats/x509');\nformats['pem'] = require('./formats/x509-pem');\nvar CertificateParseError = errs.CertificateParseError;\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\n\nfunction Certificate(opts) {\n  assert.object(opts, 'options');\n  assert.arrayOfObject(opts.subjects, 'options.subjects');\n  utils.assertCompatible(opts.subjects[0], Identity, [1, 0], 'options.subjects');\n  utils.assertCompatible(opts.subjectKey, Key, [1, 0], 'options.subjectKey');\n  utils.assertCompatible(opts.issuer, Identity, [1, 0], 'options.issuer');\n\n  if (opts.issuerKey !== undefined) {\n    utils.assertCompatible(opts.issuerKey, Key, [1, 0], 'options.issuerKey');\n  }\n\n  assert.object(opts.signatures, 'options.signatures');\n  assert.buffer(opts.serial, 'options.serial');\n  assert.date(opts.validFrom, 'options.validFrom');\n  assert.date(opts.validUntil, 'optons.validUntil');\n  assert.optionalArrayOfString(opts.purposes, 'options.purposes');\n  this._hashCache = {};\n  this.subjects = opts.subjects;\n  this.issuer = opts.issuer;\n  this.subjectKey = opts.subjectKey;\n  this.issuerKey = opts.issuerKey;\n  this.signatures = opts.signatures;\n  this.serial = opts.serial;\n  this.validFrom = opts.validFrom;\n  this.validUntil = opts.validUntil;\n  this.purposes = opts.purposes;\n}\n\nCertificate.formats = formats;\n\nCertificate.prototype.toBuffer = function (format, options) {\n  if (format === undefined) format = 'x509';\n  assert.string(format, 'format');\n  assert.object(formats[format], 'formats[format]');\n  assert.optionalObject(options, 'options');\n  return formats[format].write(this, options);\n};\n\nCertificate.prototype.toString = function (format, options) {\n  if (format === undefined) format = 'pem';\n  return this.toBuffer(format, options).toString();\n};\n\nCertificate.prototype.fingerprint = function (algo) {\n  if (algo === undefined) algo = 'sha256';\n  assert.string(algo, 'algorithm');\n  var opts = {\n    type: 'certificate',\n    hash: this.hash(algo),\n    algorithm: algo\n  };\n  return new Fingerprint(opts);\n};\n\nCertificate.prototype.hash = function (algo) {\n  assert.string(algo, 'algorithm');\n  algo = algo.toLowerCase();\n  if (algs.hashAlgs[algo] === undefined) throw new InvalidAlgorithmError(algo);\n  if (this._hashCache[algo]) return this._hashCache[algo];\n  var hash = crypto.createHash(algo).update(this.toBuffer('x509')).digest();\n  this._hashCache[algo] = hash;\n  return hash;\n};\n\nCertificate.prototype.isExpired = function (when) {\n  if (when === undefined) when = new Date();\n  return !(when.getTime() >= this.validFrom.getTime() && when.getTime() < this.validUntil.getTime());\n};\n\nCertificate.prototype.isSignedBy = function (issuerCert) {\n  utils.assertCompatible(issuerCert, Certificate, [1, 0], 'issuer');\n  if (!this.issuer.equals(issuerCert.subjects[0])) return false;\n\n  if (this.issuer.purposes && this.issuer.purposes.length > 0 && this.issuer.purposes.indexOf('ca') === -1) {\n    return false;\n  }\n\n  return this.isSignedByKey(issuerCert.subjectKey);\n};\n\nCertificate.prototype.getExtension = function (keyOrOid) {\n  assert.string(keyOrOid, 'keyOrOid');\n  var ext = this.getExtensions().filter(function (maybeExt) {\n    if (maybeExt.format === 'x509') return maybeExt.oid === keyOrOid;\n    if (maybeExt.format === 'openssh') return maybeExt.name === keyOrOid;\n    return false;\n  })[0];\n  return ext;\n};\n\nCertificate.prototype.getExtensions = function () {\n  var exts = [];\n  var x509 = this.signatures.x509;\n\n  if (x509 && x509.extras && x509.extras.exts) {\n    x509.extras.exts.forEach(function (ext) {\n      ext.format = 'x509';\n      exts.push(ext);\n    });\n  }\n\n  var openssh = this.signatures.openssh;\n\n  if (openssh && openssh.exts) {\n    openssh.exts.forEach(function (ext) {\n      ext.format = 'openssh';\n      exts.push(ext);\n    });\n  }\n\n  return exts;\n};\n\nCertificate.prototype.isSignedByKey = function (issuerKey) {\n  utils.assertCompatible(issuerKey, Key, [1, 2], 'issuerKey');\n\n  if (this.issuerKey !== undefined) {\n    return this.issuerKey.fingerprint('sha512').matches(issuerKey);\n  }\n\n  var fmt = Object.keys(this.signatures)[0];\n  var valid = formats[fmt].verify(this, issuerKey);\n  if (valid) this.issuerKey = issuerKey;\n  return valid;\n};\n\nCertificate.prototype.signWith = function (key) {\n  utils.assertCompatible(key, PrivateKey, [1, 2], 'key');\n  var fmts = Object.keys(formats);\n  var didOne = false;\n\n  for (var i = 0; i < fmts.length; ++i) {\n    if (fmts[i] !== 'pem') {\n      var ret = formats[fmts[i]].sign(this, key);\n      if (ret === true) didOne = true;\n    }\n  }\n\n  if (!didOne) {\n    throw new Error('Failed to sign the certificate for any ' + 'available certificate formats');\n  }\n};\n\nCertificate.createSelfSigned = function (subjectOrSubjects, key, options) {\n  var subjects;\n  if (Array.isArray(subjectOrSubjects)) subjects = subjectOrSubjects;else subjects = [subjectOrSubjects];\n  assert.arrayOfObject(subjects);\n  subjects.forEach(function (subject) {\n    utils.assertCompatible(subject, Identity, [1, 0], 'subject');\n  });\n  utils.assertCompatible(key, PrivateKey, [1, 2], 'private key');\n  assert.optionalObject(options, 'options');\n  if (options === undefined) options = {};\n  assert.optionalObject(options.validFrom, 'options.validFrom');\n  assert.optionalObject(options.validUntil, 'options.validUntil');\n  var validFrom = options.validFrom;\n  var validUntil = options.validUntil;\n  if (validFrom === undefined) validFrom = new Date();\n\n  if (validUntil === undefined) {\n    assert.optionalNumber(options.lifetime, 'options.lifetime');\n    var lifetime = options.lifetime;\n    if (lifetime === undefined) lifetime = 10 * 365 * 24 * 3600;\n    validUntil = new Date();\n    validUntil.setTime(validUntil.getTime() + lifetime * 1000);\n  }\n\n  assert.optionalBuffer(options.serial, 'options.serial');\n  var serial = options.serial;\n  if (serial === undefined) serial = Buffer.from('0000000000000001', 'hex');\n  var purposes = options.purposes;\n  if (purposes === undefined) purposes = [];\n  if (purposes.indexOf('signature') === -1) purposes.push('signature');\n  /* Self-signed certs are always CAs. */\n\n  if (purposes.indexOf('ca') === -1) purposes.push('ca');\n  if (purposes.indexOf('crl') === -1) purposes.push('crl');\n  /*\n   * If we weren't explicitly given any other purposes, do the sensible\n   * thing and add some basic ones depending on the subject type.\n   */\n\n  if (purposes.length <= 3) {\n    var hostSubjects = subjects.filter(function (subject) {\n      return subject.type === 'host';\n    });\n    var userSubjects = subjects.filter(function (subject) {\n      return subject.type === 'user';\n    });\n\n    if (hostSubjects.length > 0) {\n      if (purposes.indexOf('serverAuth') === -1) purposes.push('serverAuth');\n    }\n\n    if (userSubjects.length > 0) {\n      if (purposes.indexOf('clientAuth') === -1) purposes.push('clientAuth');\n    }\n\n    if (userSubjects.length > 0 || hostSubjects.length > 0) {\n      if (purposes.indexOf('keyAgreement') === -1) purposes.push('keyAgreement');\n      if (key.type === 'rsa' && purposes.indexOf('encryption') === -1) purposes.push('encryption');\n    }\n  }\n\n  var cert = new Certificate({\n    subjects: subjects,\n    issuer: subjects[0],\n    subjectKey: key.toPublic(),\n    issuerKey: key.toPublic(),\n    signatures: {},\n    serial: serial,\n    validFrom: validFrom,\n    validUntil: validUntil,\n    purposes: purposes\n  });\n  cert.signWith(key);\n  return cert;\n};\n\nCertificate.create = function (subjectOrSubjects, key, issuer, issuerKey, options) {\n  var subjects;\n  if (Array.isArray(subjectOrSubjects)) subjects = subjectOrSubjects;else subjects = [subjectOrSubjects];\n  assert.arrayOfObject(subjects);\n  subjects.forEach(function (subject) {\n    utils.assertCompatible(subject, Identity, [1, 0], 'subject');\n  });\n  utils.assertCompatible(key, Key, [1, 0], 'key');\n  if (PrivateKey.isPrivateKey(key)) key = key.toPublic();\n  utils.assertCompatible(issuer, Identity, [1, 0], 'issuer');\n  utils.assertCompatible(issuerKey, PrivateKey, [1, 2], 'issuer key');\n  assert.optionalObject(options, 'options');\n  if (options === undefined) options = {};\n  assert.optionalObject(options.validFrom, 'options.validFrom');\n  assert.optionalObject(options.validUntil, 'options.validUntil');\n  var validFrom = options.validFrom;\n  var validUntil = options.validUntil;\n  if (validFrom === undefined) validFrom = new Date();\n\n  if (validUntil === undefined) {\n    assert.optionalNumber(options.lifetime, 'options.lifetime');\n    var lifetime = options.lifetime;\n    if (lifetime === undefined) lifetime = 10 * 365 * 24 * 3600;\n    validUntil = new Date();\n    validUntil.setTime(validUntil.getTime() + lifetime * 1000);\n  }\n\n  assert.optionalBuffer(options.serial, 'options.serial');\n  var serial = options.serial;\n  if (serial === undefined) serial = Buffer.from('0000000000000001', 'hex');\n  var purposes = options.purposes;\n  if (purposes === undefined) purposes = [];\n  if (purposes.indexOf('signature') === -1) purposes.push('signature');\n\n  if (options.ca === true) {\n    if (purposes.indexOf('ca') === -1) purposes.push('ca');\n    if (purposes.indexOf('crl') === -1) purposes.push('crl');\n  }\n\n  var hostSubjects = subjects.filter(function (subject) {\n    return subject.type === 'host';\n  });\n  var userSubjects = subjects.filter(function (subject) {\n    return subject.type === 'user';\n  });\n\n  if (hostSubjects.length > 0) {\n    if (purposes.indexOf('serverAuth') === -1) purposes.push('serverAuth');\n  }\n\n  if (userSubjects.length > 0) {\n    if (purposes.indexOf('clientAuth') === -1) purposes.push('clientAuth');\n  }\n\n  if (userSubjects.length > 0 || hostSubjects.length > 0) {\n    if (purposes.indexOf('keyAgreement') === -1) purposes.push('keyAgreement');\n    if (key.type === 'rsa' && purposes.indexOf('encryption') === -1) purposes.push('encryption');\n  }\n\n  var cert = new Certificate({\n    subjects: subjects,\n    issuer: issuer,\n    subjectKey: key,\n    issuerKey: issuerKey.toPublic(),\n    signatures: {},\n    serial: serial,\n    validFrom: validFrom,\n    validUntil: validUntil,\n    purposes: purposes\n  });\n  cert.signWith(issuerKey);\n  return cert;\n};\n\nCertificate.parse = function (data, format, options) {\n  if (typeof data !== 'string') assert.buffer(data, 'data');\n  if (format === undefined) format = 'auto';\n  assert.string(format, 'format');\n  if (typeof options === 'string') options = {\n    filename: options\n  };\n  assert.optionalObject(options, 'options');\n  if (options === undefined) options = {};\n  assert.optionalString(options.filename, 'options.filename');\n  if (options.filename === undefined) options.filename = '(unnamed)';\n  assert.object(formats[format], 'formats[format]');\n\n  try {\n    var k = formats[format].read(data, options);\n    return k;\n  } catch (e) {\n    throw new CertificateParseError(options.filename, format, e);\n  }\n};\n\nCertificate.isCertificate = function (obj, ver) {\n  return utils.isCompatible(obj, Certificate, ver);\n};\n/*\n * API versions for Certificate:\n * [1,0] -- initial ver\n * [1,1] -- openssh format now unpacks extensions\n */\n\n\nCertificate.prototype._sshpkApiVersion = [1, 1];\n\nCertificate._oldVersionDetect = function (obj) {\n  return [1, 0];\n};","map":null,"metadata":{},"sourceType":"script"}